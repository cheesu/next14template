<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì¤‘ì‹¬ì  ê³„ì‚° ë°©ë²• ë¹„êµ</title>
    <style>
        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; background: #f0f0f0; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; color: #333; }
        .demo-area { background: white; border-radius: 10px; padding: 20px; margin: 20px 0; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .controls { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        button { padding: 10px 15px; cursor: pointer; border: none; border-radius: 5px; background: #007bff; color: white; }
        button:hover { background: #0056b3; }
        .info { background: #e9f7ff; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .results { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-top: 20px; }
        .result-box { background: #f8f9fa; padding: 15px; border-radius: 5px; border-left: 4px solid #007bff; }
        .center-point { font-weight: bold; color: #dc3545; }
        canvas { border: 1px solid #ddd; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¯ ì¤‘ì‹¬ì  ê³„ì‚° ë°©ë²• ë¹„êµ</h1>
        
        <div class="demo-area">
            <h2>ğŸ“ 2D ì‹œê°í™” ë°ëª¨</h2>
            <div class="controls">
                <button onclick="generateRandomPoints()">ğŸ² ëœë¤ ì  ìƒì„±</button>
                <button onclick="generateClusteredPoints()">ğŸ“ í´ëŸ¬ìŠ¤í„° ì  ìƒì„±</button>
                <button onclick="generateLinePoints()">ğŸ“ ì„ í˜• ì  ìƒì„±</button>
                <button onclick="clearCanvas()">ğŸ§¹ ì§€ìš°ê¸°</button>
            </div>
            
            <div class="info">
                <strong>ì‚¬ìš©ë²•:</strong> ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ë‹¤ì–‘í•œ ì  íŒ¨í„´ì„ ìƒì„±í•˜ê³ , ê° ë°©ë²•ìœ¼ë¡œ ê³„ì‚°ëœ ì¤‘ì‹¬ì ì„ ë¹„êµí•´ë³´ì„¸ìš”!<br>
                <strong>ìƒ‰ìƒ:</strong> ğŸ”´ ì‚°ìˆ í‰ê·  | ğŸŸ¢ ê¸°í•˜ì¤‘ì‹¬ | ğŸ”µ ê°€ì¤‘í‰ê·  | âš« ì›ë³¸ ì ë“¤
            </div>
            
            <canvas id="canvas" width="800" height="400"></canvas>
            
            <div class="results">
                <div class="result-box">
                    <h3>ğŸ”´ ì‚°ìˆ  í‰ê·  (Centroid)</h3>
                    <div id="centroid-result">ì ì„ ìƒì„±í•˜ì„¸ìš”</div>
                    <p><strong>íŠ¹ì§•:</strong> ëª¨ë“  ì ì˜ í‰ê·  ìœ„ì¹˜. ê°€ì¥ ì¼ë°˜ì .</p>
                </div>
                
                <div class="result-box">
                    <h3>ğŸŸ¢ ê¸°í•˜í•™ì  ì¤‘ì‹¬</h3>
                    <div id="bbox-result">ì ì„ ìƒì„±í•˜ì„¸ìš”</div>
                    <p><strong>íŠ¹ì§•:</strong> ì˜ì—­ì˜ ì •ì¤‘ì•™. ë¶„í¬ì™€ ë¬´ê´€.</p>
                </div>
                
                <div class="result-box">
                    <h3>ğŸ”µ ê°€ì¤‘ í‰ê· </h3>
                    <div id="weighted-result">ì ì„ ìƒì„±í•˜ì„¸ìš”</div>
                    <p><strong>íŠ¹ì§•:</strong> í° ì ì´ ë” ë§ì€ ì˜í–¥. í¬ê¸° ê³ ë ¤.</p>
                </div>
            </div>
        </div>
        
        <div class="demo-area">
            <h2>ğŸ“Š ì‹¤ì œ ê³„ì‚° ê³¼ì •</h2>
            <div id="calculation-details">
                ì ì„ ìƒì„±í•˜ë©´ ì—¬ê¸°ì— ê³„ì‚° ê³¼ì •ì´ í‘œì‹œë©ë‹ˆë‹¤.
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let points = [];

        function generateRandomPoints() {
            points = [];
            for (let i = 0; i < 15; i++) {
                points.push({
                    x: Math.random() * 700 + 50,
                    y: Math.random() * 300 + 50,
                    size: Math.random() * 15 + 5,
                    id: i + 1
                });
            }
            updateVisualization();
        }

        function generateClusteredPoints() {
            points = [];
            // í´ëŸ¬ìŠ¤í„° 1
            for (let i = 0; i < 8; i++) {
                points.push({
                    x: Math.random() * 150 + 100,
                    y: Math.random() * 100 + 100,
                    size: Math.random() * 10 + 5,
                    id: i + 1
                });
            }
            // í´ëŸ¬ìŠ¤í„° 2
            for (let i = 0; i < 7; i++) {
                points.push({
                    x: Math.random() * 150 + 500,
                    y: Math.random() * 100 + 200,
                    size: Math.random() * 15 + 8,
                    id: i + 9
                });
            }
            updateVisualization();
        }

        function generateLinePoints() {
            points = [];
            for (let i = 0; i < 12; i++) {
                const t = i / 11;
                points.push({
                    x: 100 + t * 600,
                    y: 200 + Math.sin(t * Math.PI * 2) * 100,
                    size: Math.random() * 12 + 4,
                    id: i + 1
                });
            }
            updateVisualization();
        }

        function clearCanvas() {
            points = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('centroid-result').textContent = 'ì ì„ ìƒì„±í•˜ì„¸ìš”';
            document.getElementById('bbox-result').textContent = 'ì ì„ ìƒì„±í•˜ì„¸ìš”';
            document.getElementById('weighted-result').textContent = 'ì ì„ ìƒì„±í•˜ì„¸ìš”';
            document.getElementById('calculation-details').textContent = 'ì ì„ ìƒì„±í•˜ë©´ ì—¬ê¸°ì— ê³„ì‚° ê³¼ì •ì´ í‘œì‹œë©ë‹ˆë‹¤.';
        }

        function calculateCentroid(points) {
            let sumX = 0, sumY = 0;
            points.forEach(p => {
                sumX += p.x;
                sumY += p.y;
            });
            return {
                x: sumX / points.length,
                y: sumY / points.length
            };
        }

        function calculateBoundingBoxCenter(points) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            points.forEach(p => {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            });
            
            return {
                x: (minX + maxX) / 2,
                y: (minY + maxY) / 2,
                bounds: { minX, maxX, minY, maxY }
            };
        }

        function calculateWeightedCenter(points) {
            let weightedX = 0, weightedY = 0, totalWeight = 0;
            
            points.forEach(p => {
                const weight = p.size; // í¬ê¸°ë¥¼ ê°€ì¤‘ì¹˜ë¡œ ì‚¬ìš©
                weightedX += p.x * weight;
                weightedY += p.y * weight;
                totalWeight += weight;
            });
            
            return {
                x: weightedX / totalWeight,
                y: weightedY / totalWeight
            };
        }

        function drawPoint(x, y, size, color = '#333', label = '') {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            if (label) {
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(label, x, y + 4);
            }
        }

        function drawCenterPoint(x, y, color, label) {
            // í° ì›
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, 15, 0, Math.PI * 2);
            ctx.stroke();
            
            // ì‘ì€ ì¤‘ì‹¬ì 
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // ë¼ë²¨
            ctx.fillStyle = color;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, x, y - 25);
        }

        function updateVisualization() {
            if (points.length === 0) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ê³„ì‚°
            const centroid = calculateCentroid(points);
            const bboxCenter = calculateBoundingBoxCenter(points);
            const weightedCenter = calculateWeightedCenter(points);
            
            // ê²½ê³„ ë°•ìŠ¤ ê·¸ë¦¬ê¸°
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(
                bboxCenter.bounds.minX,
                bboxCenter.bounds.minY,
                bboxCenter.bounds.maxX - bboxCenter.bounds.minX,
                bboxCenter.bounds.maxY - bboxCenter.bounds.minY
            );
            ctx.setLineDash([]);
            
            // ì›ë³¸ ì ë“¤ ê·¸ë¦¬ê¸°
            points.forEach(p => {
                drawPoint(p.x, p.y, p.size / 2, '#333', p.id.toString());
            });
            
            // ì¤‘ì‹¬ì ë“¤ ê·¸ë¦¬ê¸°
            drawCenterPoint(centroid.x, centroid.y, '#dc3545', 'ì‚°ìˆ ');
            drawCenterPoint(bboxCenter.x, bboxCenter.y, '#28a745', 'ê¸°í•˜');
            drawCenterPoint(weightedCenter.x, weightedCenter.y, '#007bff', 'ê°€ì¤‘');
            
            // ê²°ê³¼ ì—…ë°ì´íŠ¸
            document.getElementById('centroid-result').innerHTML = 
                `<div class="center-point">(${centroid.x.toFixed(1)}, ${centroid.y.toFixed(1)})</div>`;
            
            document.getElementById('bbox-result').innerHTML = 
                `<div class="center-point">(${bboxCenter.x.toFixed(1)}, ${bboxCenter.y.toFixed(1)})</div>`;
            
            document.getElementById('weighted-result').innerHTML = 
                `<div class="center-point">(${weightedCenter.x.toFixed(1)}, ${weightedCenter.y.toFixed(1)})</div>`;
            
            // ê³„ì‚° ê³¼ì • í‘œì‹œ
            showCalculationDetails(points, centroid, bboxCenter, weightedCenter);
        }

        function showCalculationDetails(points, centroid, bboxCenter, weightedCenter) {
            const details = `
                <h3>ğŸ§® ì‚°ìˆ  í‰ê·  ê³„ì‚° ê³¼ì •</h3>
                <p><strong>1ë‹¨ê³„:</strong> ëª¨ë“  Xì¢Œí‘œ í•©ê³„ = ${points.map(p => p.x.toFixed(1)).join(' + ')} = ${(points.reduce((sum, p) => sum + p.x, 0)).toFixed(1)}</p>
                <p><strong>2ë‹¨ê³„:</strong> ëª¨ë“  Yì¢Œí‘œ í•©ê³„ = ${points.map(p => p.y.toFixed(1)).join(' + ')} = ${(points.reduce((sum, p) => sum + p.y, 0)).toFixed(1)}</p>
                <p><strong>3ë‹¨ê³„:</strong> í‰ê·  ê³„ì‚° = (${(points.reduce((sum, p) => sum + p.x, 0)).toFixed(1)} / ${points.length}, ${(points.reduce((sum, p) => sum + p.y, 0)).toFixed(1)} / ${points.length}) = <span class="center-point">(${centroid.x.toFixed(1)}, ${centroid.y.toFixed(1)})</span></p>
                
                <h3>ğŸ“¦ ê¸°í•˜í•™ì  ì¤‘ì‹¬ ê³„ì‚° ê³¼ì •</h3>
                <p><strong>1ë‹¨ê³„:</strong> X ë²”ìœ„ = ${bboxCenter.bounds.minX.toFixed(1)} ~ ${bboxCenter.bounds.maxX.toFixed(1)}</p>
                <p><strong>2ë‹¨ê³„:</strong> Y ë²”ìœ„ = ${bboxCenter.bounds.minY.toFixed(1)} ~ ${bboxCenter.bounds.maxY.toFixed(1)}</p>
                <p><strong>3ë‹¨ê³„:</strong> ì¤‘ê°„ê°’ = ((${bboxCenter.bounds.minX.toFixed(1)} + ${bboxCenter.bounds.maxX.toFixed(1)}) / 2, (${bboxCenter.bounds.minY.toFixed(1)} + ${bboxCenter.bounds.maxY.toFixed(1)}) / 2) = <span class="center-point">(${bboxCenter.x.toFixed(1)}, ${bboxCenter.y.toFixed(1)})</span></p>
            `;
            
            document.getElementById('calculation-details').innerHTML = details;
        }

        // ì´ˆê¸° ì  ìƒì„±
        generateRandomPoints();
    </script>
</body>
</html> 