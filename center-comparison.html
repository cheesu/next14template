<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>중심점 계산 방법 비교</title>
    <style>
        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; background: #f0f0f0; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; color: #333; }
        .demo-area { background: white; border-radius: 10px; padding: 20px; margin: 20px 0; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .controls { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        button { padding: 10px 15px; cursor: pointer; border: none; border-radius: 5px; background: #007bff; color: white; }
        button:hover { background: #0056b3; }
        .info { background: #e9f7ff; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .results { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-top: 20px; }
        .result-box { background: #f8f9fa; padding: 15px; border-radius: 5px; border-left: 4px solid #007bff; }
        .center-point { font-weight: bold; color: #dc3545; }
        canvas { border: 1px solid #ddd; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎯 중심점 계산 방법 비교</h1>
        
        <div class="demo-area">
            <h2>📐 2D 시각화 데모</h2>
            <div class="controls">
                <button onclick="generateRandomPoints()">🎲 랜덤 점 생성</button>
                <button onclick="generateClusteredPoints()">📍 클러스터 점 생성</button>
                <button onclick="generateLinePoints()">📏 선형 점 생성</button>
                <button onclick="clearCanvas()">🧹 지우기</button>
            </div>
            
            <div class="info">
                <strong>사용법:</strong> 버튼을 클릭하여 다양한 점 패턴을 생성하고, 각 방법으로 계산된 중심점을 비교해보세요!<br>
                <strong>색상:</strong> 🔴 산술평균 | 🟢 기하중심 | 🔵 가중평균 | ⚫ 원본 점들
            </div>
            
            <canvas id="canvas" width="800" height="400"></canvas>
            
            <div class="results">
                <div class="result-box">
                    <h3>🔴 산술 평균 (Centroid)</h3>
                    <div id="centroid-result">점을 생성하세요</div>
                    <p><strong>특징:</strong> 모든 점의 평균 위치. 가장 일반적.</p>
                </div>
                
                <div class="result-box">
                    <h3>🟢 기하학적 중심</h3>
                    <div id="bbox-result">점을 생성하세요</div>
                    <p><strong>특징:</strong> 영역의 정중앙. 분포와 무관.</p>
                </div>
                
                <div class="result-box">
                    <h3>🔵 가중 평균</h3>
                    <div id="weighted-result">점을 생성하세요</div>
                    <p><strong>특징:</strong> 큰 점이 더 많은 영향. 크기 고려.</p>
                </div>
            </div>
        </div>
        
        <div class="demo-area">
            <h2>📊 실제 계산 과정</h2>
            <div id="calculation-details">
                점을 생성하면 여기에 계산 과정이 표시됩니다.
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let points = [];

        function generateRandomPoints() {
            points = [];
            for (let i = 0; i < 15; i++) {
                points.push({
                    x: Math.random() * 700 + 50,
                    y: Math.random() * 300 + 50,
                    size: Math.random() * 15 + 5,
                    id: i + 1
                });
            }
            updateVisualization();
        }

        function generateClusteredPoints() {
            points = [];
            // 클러스터 1
            for (let i = 0; i < 8; i++) {
                points.push({
                    x: Math.random() * 150 + 100,
                    y: Math.random() * 100 + 100,
                    size: Math.random() * 10 + 5,
                    id: i + 1
                });
            }
            // 클러스터 2
            for (let i = 0; i < 7; i++) {
                points.push({
                    x: Math.random() * 150 + 500,
                    y: Math.random() * 100 + 200,
                    size: Math.random() * 15 + 8,
                    id: i + 9
                });
            }
            updateVisualization();
        }

        function generateLinePoints() {
            points = [];
            for (let i = 0; i < 12; i++) {
                const t = i / 11;
                points.push({
                    x: 100 + t * 600,
                    y: 200 + Math.sin(t * Math.PI * 2) * 100,
                    size: Math.random() * 12 + 4,
                    id: i + 1
                });
            }
            updateVisualization();
        }

        function clearCanvas() {
            points = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('centroid-result').textContent = '점을 생성하세요';
            document.getElementById('bbox-result').textContent = '점을 생성하세요';
            document.getElementById('weighted-result').textContent = '점을 생성하세요';
            document.getElementById('calculation-details').textContent = '점을 생성하면 여기에 계산 과정이 표시됩니다.';
        }

        function calculateCentroid(points) {
            let sumX = 0, sumY = 0;
            points.forEach(p => {
                sumX += p.x;
                sumY += p.y;
            });
            return {
                x: sumX / points.length,
                y: sumY / points.length
            };
        }

        function calculateBoundingBoxCenter(points) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            points.forEach(p => {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            });
            
            return {
                x: (minX + maxX) / 2,
                y: (minY + maxY) / 2,
                bounds: { minX, maxX, minY, maxY }
            };
        }

        function calculateWeightedCenter(points) {
            let weightedX = 0, weightedY = 0, totalWeight = 0;
            
            points.forEach(p => {
                const weight = p.size; // 크기를 가중치로 사용
                weightedX += p.x * weight;
                weightedY += p.y * weight;
                totalWeight += weight;
            });
            
            return {
                x: weightedX / totalWeight,
                y: weightedY / totalWeight
            };
        }

        function drawPoint(x, y, size, color = '#333', label = '') {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            if (label) {
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(label, x, y + 4);
            }
        }

        function drawCenterPoint(x, y, color, label) {
            // 큰 원
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, 15, 0, Math.PI * 2);
            ctx.stroke();
            
            // 작은 중심점
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // 라벨
            ctx.fillStyle = color;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, x, y - 25);
        }

        function updateVisualization() {
            if (points.length === 0) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 계산
            const centroid = calculateCentroid(points);
            const bboxCenter = calculateBoundingBoxCenter(points);
            const weightedCenter = calculateWeightedCenter(points);
            
            // 경계 박스 그리기
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(
                bboxCenter.bounds.minX,
                bboxCenter.bounds.minY,
                bboxCenter.bounds.maxX - bboxCenter.bounds.minX,
                bboxCenter.bounds.maxY - bboxCenter.bounds.minY
            );
            ctx.setLineDash([]);
            
            // 원본 점들 그리기
            points.forEach(p => {
                drawPoint(p.x, p.y, p.size / 2, '#333', p.id.toString());
            });
            
            // 중심점들 그리기
            drawCenterPoint(centroid.x, centroid.y, '#dc3545', '산술');
            drawCenterPoint(bboxCenter.x, bboxCenter.y, '#28a745', '기하');
            drawCenterPoint(weightedCenter.x, weightedCenter.y, '#007bff', '가중');
            
            // 결과 업데이트
            document.getElementById('centroid-result').innerHTML = 
                `<div class="center-point">(${centroid.x.toFixed(1)}, ${centroid.y.toFixed(1)})</div>`;
            
            document.getElementById('bbox-result').innerHTML = 
                `<div class="center-point">(${bboxCenter.x.toFixed(1)}, ${bboxCenter.y.toFixed(1)})</div>`;
            
            document.getElementById('weighted-result').innerHTML = 
                `<div class="center-point">(${weightedCenter.x.toFixed(1)}, ${weightedCenter.y.toFixed(1)})</div>`;
            
            // 계산 과정 표시
            showCalculationDetails(points, centroid, bboxCenter, weightedCenter);
        }

        function showCalculationDetails(points, centroid, bboxCenter, weightedCenter) {
            const details = `
                <h3>🧮 산술 평균 계산 과정</h3>
                <p><strong>1단계:</strong> 모든 X좌표 합계 = ${points.map(p => p.x.toFixed(1)).join(' + ')} = ${(points.reduce((sum, p) => sum + p.x, 0)).toFixed(1)}</p>
                <p><strong>2단계:</strong> 모든 Y좌표 합계 = ${points.map(p => p.y.toFixed(1)).join(' + ')} = ${(points.reduce((sum, p) => sum + p.y, 0)).toFixed(1)}</p>
                <p><strong>3단계:</strong> 평균 계산 = (${(points.reduce((sum, p) => sum + p.x, 0)).toFixed(1)} / ${points.length}, ${(points.reduce((sum, p) => sum + p.y, 0)).toFixed(1)} / ${points.length}) = <span class="center-point">(${centroid.x.toFixed(1)}, ${centroid.y.toFixed(1)})</span></p>
                
                <h3>📦 기하학적 중심 계산 과정</h3>
                <p><strong>1단계:</strong> X 범위 = ${bboxCenter.bounds.minX.toFixed(1)} ~ ${bboxCenter.bounds.maxX.toFixed(1)}</p>
                <p><strong>2단계:</strong> Y 범위 = ${bboxCenter.bounds.minY.toFixed(1)} ~ ${bboxCenter.bounds.maxY.toFixed(1)}</p>
                <p><strong>3단계:</strong> 중간값 = ((${bboxCenter.bounds.minX.toFixed(1)} + ${bboxCenter.bounds.maxX.toFixed(1)}) / 2, (${bboxCenter.bounds.minY.toFixed(1)} + ${bboxCenter.bounds.maxY.toFixed(1)}) / 2) = <span class="center-point">(${bboxCenter.x.toFixed(1)}, ${bboxCenter.y.toFixed(1)})</span></p>
            `;
            
            document.getElementById('calculation-details').innerHTML = details;
        }

        // 초기 점 생성
        generateRandomPoints();
    </script>
</body>
</html> 